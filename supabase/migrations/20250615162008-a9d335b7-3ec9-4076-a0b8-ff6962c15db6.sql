
-- Create storage bucket for channel attachments
INSERT INTO storage.buckets (id, name, public)
VALUES ('channel_attachments', 'channel_attachments', true)
ON CONFLICT (id) DO NOTHING;

-- Add policies for channel attachments bucket to allow public reads and authenticated uploads
CREATE POLICY "Public read access for channel attachments"
ON storage.objects FOR SELECT
USING ( bucket_id = 'channel_attachments' );

CREATE POLICY "Authenticated users can upload channel attachments"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'channel_attachments' );

-- Add attachment columns to the channel_messages table
ALTER TABLE public.channel_messages
ADD COLUMN IF NOT EXISTS attachment_url TEXT,
ADD COLUMN IF NOT EXISTS attachment_type TEXT;

-- Create the missing 'channel_type' enum which caused the previous error.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'channel_type') THEN
        CREATE TYPE public.channel_type AS ENUM ('text', 'voice');
    END IF;
END$$;

-- Add the 'type' column to the 'channels' table.
ALTER TABLE public.channels
ADD COLUMN IF NOT EXISTS type public.channel_type NOT NULL DEFAULT 'text';

-- Create the table for tracking last-read times for unread message counts.
CREATE TABLE IF NOT EXISTS public.channel_last_read (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    channel_id UUID NOT NULL REFERENCES public.channels(id) ON DELETE CASCADE,
    last_read_at TIMESTAMPTZ NOT NULL,
    UNIQUE (user_id, channel_id)
);

-- Enable Row Level Security on the new table.
ALTER TABLE public.channel_last_read ENABLE ROW LEVEL SECURITY;

-- Create the policy for managing last-read timestamps.
DROP POLICY IF EXISTS "Users can manage their own last_read timestamps" ON public.channel_last_read;
CREATE POLICY "Users can manage their own last_read timestamps"
ON public.channel_last_read
FOR ALL
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Re-create the function to mark a channel as read.
CREATE OR REPLACE FUNCTION public.mark_channel_as_read(p_channel_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.channel_last_read (user_id, channel_id, last_read_at)
  VALUES (auth.uid(), p_channel_id, now())
  ON CONFLICT (user_id, channel_id)
  DO UPDATE SET last_read_at = now();
END;
$$;

-- Re-create the function to get joined channels with unread counts.
CREATE OR REPLACE FUNCTION public.get_joined_channels_with_unread(p_user_id uuid)
RETURNS TABLE (
    id uuid,
    created_at timestamptz,
    name text,
    description text,
    genre public.channel_genre,
    visibility public.channel_visibility,
    creator_id uuid,
    image_url text,
    color text,
    logo_letter text,
    type public.channel_type,
    unread_count bigint
)
LANGUAGE sql
STABLE
AS $$
SELECT
    c.id,
    c.created_at,
    c.name,
    c.description,
    c.genre,
    c.visibility,
    c.creator_id,
    c.image_url,
    c.color,
    c.logo_letter,
    c.type,
    (
        SELECT COUNT(*)
        FROM public.channel_messages AS cm
        WHERE cm.channel_id = c.id
          AND cm.user_id != p_user_id
          AND cm.created_at > COALESCE(clr.last_read_at, '1970-01-01'::timestamptz)
    ) AS unread_count
FROM
    public.channels AS c
JOIN
    public.channel_members AS cmem ON c.id = cmem.channel_id
LEFT JOIN
    public.channel_last_read AS clr ON c.id = clr.channel_id AND clr.user_id = p_user_id
WHERE
    cmem.user_id = p_user_id
ORDER BY
    c.name;
$$;
